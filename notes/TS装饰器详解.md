# TS 装饰器详解

- 装饰器的本质其实就是一个函数, 只不过它的入参是提前确定好的。同时 TS 中的装饰器目前只能在类以及类成员上使用。

* 装饰器通过 @ 语法来使用

```
function Deco(){}

@Deco
class Foo{}


```

- 装饰器工厂

* 在这种情况下,程序执行时会先执行 Deco(),再用内部返回的函数作为装饰器的实际逻辑。
* 这样 我们就可以通过入参来灵活地调整装饰器的作用。

```

function Deco(){
    return ()=>{}
}

@Deco()
class Foo{}

```

## 类装饰器

- 类装饰器是直接作用在类上的装饰器,它在执行时的入参只有一个,那就是这个类的本身(而不是类的原型对象)。
- 因此 我们就可以通过类装饰器来覆盖类的属性与方法,如果你在类装饰器中返回一个新的类,它甚至可以篡改掉整个类的实现。

## 方法装饰器

- 方法装饰器的入参包括类的原型 方法名以及方法的属性描述符,而通过属性描述符你可以控制这个方法的内部实现等信息。

* 方法装饰器的 target 是类的原型而非类本身。

## 访问符装饰器

- 访问符装饰器 其实就是 get value(){} set value(v)=>{}

* 其中 getter 在你访问这个属性 value 时触发,而 setter 在你对 value 进行赋值时触发。
* 访问符装饰器本质上任然是方法装饰器,它们使用的定义也相同。
* 访问符装饰器只能同时应用在一对 getter/setter 的其中一个,即要么装饰 getter 要么装饰 setter。这是因为,不论你是装饰哪一个装饰器入参中的属性描述符都包括 getter setter 方法。

## 属性装饰器

- 属性装饰器在独立使用时能力非常有限,它的入参只有类的原型与属性名称,返回值会被忽略,但你仍然可以通过直接在类的原型上赋值来修改属性。

## 参数装饰器

- 参数装饰器包括了构造函数的参数装饰器与方法的参数装饰器，它的入参包括类的原型、参数所在的方法名与参数在函数参数中的索引值（即第几个参数），如果只是单独使用，它的作用同样非常有限

# 装饰器的执行机制

- 装饰器的执行机制中主要包括 执行时机 执行原理以及 执行顺序这个三个概念

* 执行时机 装饰器本质就是一个函数 因此只要在类上定义了它,即使不去实例化这个类或者读取静态成员,它也会正常执行。
* 很多时候,其实我们也并不会实例化具有装饰器的类, 而是通过 反射元数据的能力来消费。
* 方法与属性装饰器时类的原型对象,而装饰器才能获得这个类本身作为参数

* 执行顺序 实例上的属性 方法 方法参数 静态的属性 方法 方法参数 最后时类以及类构造函数的参数。

* 执行顺序与应用顺序 执行时装饰器求值得到最终装饰器表达式 而应用则是最终装饰器逻辑代码执行的过程。

## 装饰器应用顺序

- 顺序大致是 实例属性-实例方法参数-构造函数参数-类

* 多个装饰器执行顺序 由上至下

* Proxy 对象的 set 方法是运行时才实际执行的,也就是说我们通过反射,在运行去修改了程序的行为。这就是反射的核心要素: 在程序运行时去检查以及修改程序行为。
* Reflect.construct 实例化一个类
* 通过 Reflect.setPrototypeOf 修改对象原型指向,这些其实都是属于反射 API

# 反射元数据 Reflect Metadata

- 元数据理解为用于描述数据的数据,如某个方法的参数信息 返回值信息就可称为该方法的元数据。

* 静态成员的元数据信息存储于构造函数,而实例成员的元数据信息存储于构造函数的原型上。

# 控制反转与依赖注入

- 控制反转的实现方式主要有两种： 依赖查找与依赖注入。 它们的本质其实均是将依赖关系的维护与创建独立出来。

```
@Provide()
class F{
    @Inject()
    d:D
}


```

- 如果别的地方需要这个类 F 时，其内部的 d 属性需要被注入一个 D 的实例，而 D 的实例又需要 A、C 的实例等等。这一系列的过程是完全交给容器的，我们需要做的就只是用装饰器简单标明下依赖关系即可。

* 而装饰器如何实现依赖注入，我想其实你也能 get 到，不就是我们上面所说的元数据吗？比如在属性中通过 Inject 装饰器注册一份元数据，告诉容器这个类的哪些属性需要被注入，然后容器会在内部存储的类里面对应地进行查找。
